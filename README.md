# java-learn
记录java学习
tip:
1.数据的存储和计算都是以补码的形式进行的。

2.在java中，位移操作是针对int和long的，在位移和计算时，char、byte、short的数据都会被自动转换成int类型来操作。

3.只使用两个变量的情况下调换它们的值:{
 a=a+b;
 b=a-b;
 a=a-b;
}

4.条件判断语句更安全的写法:字面量 == 变量；->这样在将"=="写成"="时程序会直接报错，提高程序的安全性。

5.Java中方法是平级关系，不能嵌套定义方法。main方法一般放在最上边，其他方法定义在main方法的下面，并且不需要提前声明（同一个类中）

6.一个标准的JavaBean：
    1.类名见名知意，大驼峰命名法。
    2.使用private修饰成员变量。
    3.至少提供两个构造方法：空参构造和带全部参数的构造方法。
    4.为每一个成员变量提供set和get方法。
    5.如果有其他行为，也要在类中定义。
7.Java中键盘录入有两套体系：
    ·第一套：nextInt,nextDouble,next:不接收制表符，空格，回车。遇到制表符，空格，回车就不会接收后面的内容,并且会将其顺延往下。
    ·第一套体系中接收上一个键盘录入的顺延内容时会自动舍弃开头的空格，制表符和回车。（注：只舍弃开头的）
        
    ·第二套：nextLine:可以接收空格，制表符和回车。并且遇到回车才停止接收数据。
    ·由于nextLine接收顺延数据时不会自动舍弃空格，制表符和回车，所以两套混用会导致回车传递而少一次键盘录入。
        
8.创建字符串：
    ·直接赋值创建的字符串对象存储在字符串常量池(StringTable)中，可以复用。每次复用时引用的地址值相同。
    ·使用new创建出来的字符串无法复用。每次new时都会在堆上开辟新空间用于存储此时的字符串。
        
9.String，StringBuilder，StringJoiner：

    ·String:基础操作包括：substring，replace，charAt，equals，toCharArray等，以及字符串不同创建方式导致存储位置的不同。
                    注意事项：键盘录入的字符串属于 new 出来的。
    
    ·StringBuilder:基础操作包括：append，reverse，toString等。
                    应用场景：1.字符串的拼接(不会出现中间量，节省空间和时间)。
                             2.字符串的反转。
                            
    ·StringJoiner:基础操作包括：add，toString等。
                    注意事项：1.构造方法必须带参，一种是只规定间隔，另一种是规定开头，间隔和结尾。
                             2.JDK8提出来的新特性，之前的版本无法使用StringJoiner。
                    应用场景：使用特定场景拼接字符串。

10.String拼接的底层原理：

    ·String s = "a"+"b": 没有变量的拼接：javac在编译java文件时直接生成"ab"字符串，该字符串属于串池，可以复用。
    ·String s1 = s2 + s3: 有变量参与的拼接
                    JDK8之前：先生成一个StringBuilder对象，使用sb.append()，然后使用toString()生成字符串对象。每一个"+"都会导致生成两个对象： StringBuilder 和 String。
                    JDK8之后：系统底层估计本次拼接得到的字符串大小，生成数组，将字符串放入数组中，最后再生成最终的字符串。

11.StringBuilder底层原理：
    ·默认创建大小为16的字节数组
    ·根据添加的内容长度(len)进行扩容：
            len<=16,直接存；
            16<len<=34,扩容到16*2+2=34字节；
            len>34：直接扩容到len字节。

12.static

    ·静态变量属于类，该类的全体对象共享。
    ·静态变量(方法)随着类的加载而加载，优先于对象。
    
    ·静态方法多用于工具类和测试类。
    ·静态方法无法直接调用非静态的变量和方法(没有this关键字)，但是可以在静态方法中构造对象调用。
     public class Teacher(){
         public static void show(){
             Teacher t = new Teacher();
             t.其他方法;
             
             Student s = new Student();
             s.其他方法;
             
         }
     
     }

13.extends
	
	终极父类：Object
	子类与父类的继承关系：
				private		非private
	构造方法	无法继承    无法继承	继承会违背构造方法与类名相同的规则。
	成员变量	可以继承	可以继承	私有的成员变量无法直接调用，但仍然会被子类继承。
	成员方法    无法继承    可以继承	实际上是添加到虚方法表中的方法才能被子类继承。
	
	虚方法表：非private，非final，非static修饰的方法可以添加入虚方法表中，表中的方法可以被继承。
	
	创建子类实例时，会使用一部分内存存储从父类继承下来的成员变量。
	成员变量(成员方法同理)：当子类没有重新定义该变量时，this和super都是指向父类的该变量；当子类重新定义后，this和super指向的变量地址才有区别。
	
	方法的重写(@Override)：本质是覆盖从父类继承的虚方法表中的同名方法。
						 1.只有添加到虚方法表中的方法才能被重写。
						 2.重写的方法尽量与父类保持一致。
						 3.重写方法时子类的访问权限要大于等于父类。
						 4.重写方法时子类的返回值类型要小于等于父类。
						 
	构造方法:子类的构造方法会在第一行默认加上一个父类的空参构造super()，并且super()前不许有其他语句。
	this()(前不许有其他语句):调用子类的其他构造方法，此时该构造方法就不会加上super(),因为调用的其他构造方法会自带super()。
	
	标准的JavaBean：和之前的相同，空参构造、全参构造（包括父类的变量），子类的变量提供set和get方法，需要重写的方法以及子类的特殊方法。
	
14.多态
	
	Animal a = new Dog():调用a.成员变量和a.成员方法
				编译      运行
	成员变量：	Animal   Animal      检查Animal类中有无该变量，实际运行也是输出Animal中的该变量。
	成员方法	Animal   Dog 		 检查Animal类中有无该方法，但由于子类重写覆盖了虚方法表，实际运行的时候是Dog中的重写方法。
	
	优势与弊端：父类类型参数可以接收所有子类对象；但无法调用子类的特有功能(编译看左边)。
	解决方法：强制类型转换：Dog d = (Dog)a;将a转成真正的Dog,这样就可以调用Dog的特有方法了。
	强转的问题：强转类型与实际类型不一致就会报错。
		  解决：使用instanceof: a instanceof Dog;结果返回boolean
		  JDK14新特性：a instanceof Dog d: 当结果判断为true,会自动执行：Dog d = (Dog)a;变量d可以直接使用。
		  
15.final修饰词
	
	修饰类：最终类，无法被继承。
	修饰方法：最终方法，无法被重写。
	修饰变量：常量，只能赋值一次。
	
	修饰常量时
		·基本数据类型：值无法改变。
		·引用数据类型：记录的地址值无法改变，但其内部的数据可以修改。
		·变量单词字母全部大写，多个单词用下划线分割。

17.权限修饰符
	
	 本类     本包的类    其他包子类  所有类
 	private < 默认/不写 < protected < public

18.代码块
	
	·局部代码块：用于方法内，提前结束变量的生命周期。
	·构造代码块：用在方法外，类内部，在调用构造方法时调用，优先于构造方法执行。
	·静态代码块：随着类的加载而只执行一次，用于初始化变量。
	
19.abstract 抽象类和抽象方法：
	
	抽象类：1.不一定有抽象方法，但其子类一定要重写抽象方法；
			2.无法实例化。
			
	抽象方法：1.没有方法体；
			  2.只存在在抽象类中。

20.接口 interface：一种规则
	
	接口多态：接口类作为参数时，可以接收所有实现类对象。
	1.实现类可以实现多接口
	
	2.成员特点： 成员变量：只能是常量，默认使用public static final 修饰;
				 构造方法：没有；
				 成员方法：JDK7之前默认public abstract 修饰;
				 
	3.实现类实现多接口时存在多个重名方法：只需要重写一次就行(接口中的方法都是没有方法体的)；
	
	4.接口之间可以继承，并且可以是多继承。但实现类必须重写子接口以及其父接口的所有抽象方法。
	
	有方法体的方法：默认方法、静态方法、私有方法。
	5.默认方法：显式使用default修饰；实现类可以不重写直接使用，但当实现类实现多接口中出现重名的默认方法，此时必须重写，避免方法冲突。
	注：默认方法是JDK8后新增特性，用于解决接口升级时的兼容问题。
	
	6.静态方法：·显式使用static修饰：直接使用接口名.方法名调用；
				·实现类无法继承，无法重写静态方法。在实现类中的同名方法只属于实现类。
	注：静态方法是JDK8后的新增特性。
	
	7.私有方法(JDK9新特性)：在接口中抽取重复的代码，同时不提供给外界使用。
			  ·无static修饰：提供给默认(default)方法调用；
			  ·有static修饰：提供给静态(static)方法调用；

21.适配器模式

		接口中方法过多，而实现类不需要实现那么多方法，可以使用第三个类：xxxadapter(abstract修饰)
		xxxadapter实现接口所有方法的空重写，同时作为实际实现类的父类，使得实现类可以选择性重写方法。

22.内部类
	
	1.成员内部类可以直接使用外部类的成员，包括私有；而外部类无法直接使用内部类的成员，必须先创建对象。
	
	成员内部类：
	创建实例化对象的方式：1.外部类名.内部类名 变量名 = new 外部类名(). new 内部类名(); 
						  2.当内部类被private修饰，只能使用内部类的方法返回一个实例化对象。
	同名变量调用：外部类名.this.变量名 -> 调用外部类的变量；
				  内部类会与外部类对象一起生成(两个new)，同时内部类中会自动添加一个"外部类名.this"用于指向外部类的地址空间。
	
	静态内部类：
	创建实例化对象的方式：外部类名.内部类名 变量名 = new 外部类名.内部类名(); 直接创建内部类对象。
	静态内部类无法直接调用外部类的非静态变量，需要先创建外部类对象，使用对象来调用。
	调用静态内部类的方法时：非静态方法：使用内部类对象调用；静态方法：外部类名.内部类名.方法名()调用。
	
	局部内部类：创建在方法中的内部类。
	1.外界无法直接使用，需要在方法中创建对象使用；
	2.该类可以直接访问外部类的成员，也可以访问方法内的局部变量。
	
	※匿名内部类：
	1.创建方式： new 接口/类(用于带参构造的参数){
							重写方法
							};
	2.整体包含三个特性：1.实现/继承；2.方法重写；3.创建对象。
	3.匿名内部类并非没有名字，虚拟机运行后会自动生成该类的class文件：Test$1.class。
	4.使用场景：方法的参数是一个接口或类时，可以传递实现类或子类对象，如果该类只需要使用一次，就可以用匿名内部类简化代码。
		如：method( new Animal(){
			@Override
			public void eat(){
			System.out.println("吃东西")
			};
		);
		
	5.可以使用接口名/父类名 变量名 = new 接口/类(){重写方法1,重写方法2,......};来接收匿名内部类对象。
	6.关于匿名内部类的成员特点：没有构造方法，所以创建匿名内部类的成员变量意义不大；
								同时由于编译看左边的原因，匿名内部类的成员方法也无法使用 类.方法名 调用，只能在重写的方法中调用。
				
23.Object类：关于equals方法，toString方法，clone方法

	·toString方法可以重写：返回对象的属性值。

	·equals()方法可以被重写，在Object类中比较的是两个对象的地址值，重写后可以比较两个对象的属性值。
	·在String类中重写了equals方法：
		s.equals(Object obj)：先判断obj是否为String类型，再判断obj与s的内容是否相等；
	·非String类型：如果类中没有重写equals方法，那么obj1.equals(obj2);比较的就是两个对象的地址值。

	·clone需要重写，而且要实现接口说明该类能被克隆。
		重写时直接调用Object的clone方法实现的是浅克隆；深克隆需要重写方法或者调用第三方工具类。
	区别：
	           基本数据类型            引用数据类型                
	浅克隆      直接赋值        与本体共享同一个地址的数据
	
	深克隆      直接赋值        使用另外的地址空间，将本体指向的地址内容赋值到自己创建的地址空间中
	注：String会复用串池。

24.Objects工具类：equals，isNull，nonNull
	
	equals(a,b):方法自身会判断a是否为null，避免空指针调用方法的错误；
	            当a非空，会调用a中的equals方法：没有重写就比较a与b的地址值；重写就根据重写的内容判断。
	
	isNull(a)：判断a是否为null;
	nonNull与isNull结果相反。

25.BigInteger:一个可以存储超大数类
	
	1.可以进行类似数字的加减乘除、次幂、比较等操作，也可以转换回整数/小数（不能超过该数的范围）
	2.获取方法：三种构造方法和一个静态方法返回。
	
26.BigDecimal：存储较大小数、解决小数精度丢失的问题

	·精度丢失:Java存储小数时会先将其转换成(1.010101...*(2^e))形式。
			  以double：64bit为例：需要存储符号位，指数e，以及尾数M(1.010101...);
			  其中，当M位数过大，超过存储位数，就会导致精度丢失。
	·BigDecimal有三种获取对象的方式：
		1.使用传递小数的构造方式：传递的小数可能不准确，导致BigDecimal存储的值也不准确。
		2.传递小数字符串的构造方式：能构造出精确的BigDecimal。
		3.使用静态方法返回（精确，但无法传入大于double类型的数）：
			3.1 传递小数：无论小数值是多少，都构造新BigDecimal并返回。
			3.2 传递整数：[0~10]之间返回一个常量对象，其他值构造新BigDecimal并返回。
	·可以进行加减乘除操作，除法操作可以指定结果的位数以及舍弃方法。

27.BigInteger和BigDecimal存储方式的不同
	
	BigInteger:1.先转换成二进制；
			   2.从右到左每32位分组；(分段)
			   3从左到右依次存入一个int数组中。
	
	BigDecimal:1.将数字拆分，如 -17.25 -> ['-', '1', '7', '.', '2', '5'](正数不需要存储符号位)
			   2.将每个位置对应的ascll值存入一个int数组中。
	
	





 
