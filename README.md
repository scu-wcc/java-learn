# java-learn
记录java学习
tip:
1.数据的存储和计算都是以补码的形式进行的。

2.在java中，位移操作是针对int和long的，在位移和计算时，char、byte、short的数据都会被自动转换成int类型来操作。

3.只使用两个变量的情况下调换它们的值:{
 a=a+b;
 b=a-b;
 a=a-b;
}

4.条件判断语句更安全的写法:字面量 == 变量；->这样在将"=="写成"="时程序会直接报错，提高程序的安全性。

5.Java中方法是平级关系，不能嵌套定义方法。main方法一般放在最上边，其他方法定义在main方法的下面，并且不需要提前声明（同一个类中）

6.一个标准的JavaBean：
    1.类名见名知意，大驼峰命名法。
    2.使用private修饰成员变量。
    3.至少提供两个构造方法：空参构造和带全部参数的构造方法。
    4.为每一个成员变量提供set和get方法。
    5.如果有其他行为，也要在类中定义。
7.Java中键盘录入有两套体系：
    ·第一套：nextInt,nextDouble,next:不接收制表符，空格，回车。遇到制表符，空格，回车就不会接收后面的内容,并且会将其顺延往下。
    ·第一套体系中接收上一个键盘录入的顺延内容时会自动舍弃开头的空格，制表符和回车。（注：只舍弃开头的）
        
    ·第二套：nextLine:可以接收空格，制表符和回车。并且遇到回车才停止接收数据。
    ·由于nextLine接收顺延数据时不会自动舍弃空格，制表符和回车，所以两套混用会导致回车传递而少一次键盘录入。
        
8.创建字符串：
    ·直接赋值创建的字符串对象存储在字符串常量池(StringTable)中，可以复用。每次复用时引用的地址值相同。
    ·使用new创建出来的字符串无法复用。每次new时都会在堆上开辟新空间用于存储此时的字符串。
        
9.String，StringBuilder，StringJoiner：

    ·String:基础操作包括：substring，replace，charAt，equals，toCharArray等，以及字符串不同创建方式导致存储位置的不同。
                    注意事项：键盘录入的字符串属于 new 出来的。
    
    ·StringBuilder:基础操作包括：append，reverse，toString等。
                    应用场景：1.字符串的拼接(不会出现中间量，节省空间和时间)。
                             2.字符串的反转。
                            
    ·StringJoiner:基础操作包括：add，toString等。
                    注意事项：1.构造方法必须带参，一种是只规定间隔，另一种是规定开头，间隔和结尾。
                             2.JDK8提出来的新特性，之前的版本无法使用StringJoiner。
                    应用场景：使用特定场景拼接字符串。

10.String拼接的底层原理：

    ·String s = "a"+"b": 没有变量的拼接：javac在编译java文件时直接生成"ab"字符串，该字符串属于串池，可以复用。
    ·String s1 = s2 + s3: 有变量参与的拼接
                    JDK8之前：先生成一个StringBuilder对象，使用sb.append()，然后使用toString()生成字符串对象。每一个"+"都会导致生成两个对象： StringBuilder 和 String。
                    JDK8之后：系统底层估计本次拼接得到的字符串大小，生成数组，将字符串放入数组中，最后再生成最终的字符串。

11.StringBuilder底层原理：
    ·默认创建大小为16的字节数组
    ·根据添加的内容长度(len)进行扩容：
            len<=16,直接存；
            16<len<=34,扩容到16*2+2=34字节；
            len>34：直接扩容到len字节。

12.static

    ·静态变量属于类，该类的全体对象共享。
    ·静态变量(方法)随着类的加载而加载，优先于对象。
    
    ·静态方法多用于工具类和测试类。
    ·静态方法无法直接调用非静态的变量和方法(没有this关键字)，但是可以在静态方法中构造对象调用。
     public class Teacher(){
         public static void show(){
             Teacher t = new Teacher();
             t.其他方法;
             
             Student s = new Student();
             s.其他方法;
             
         }
     
     }

13.extends
	
	终极父类：Object
	子类与父类的继承关系：
				private		非private
	构造方法	无法继承    无法继承	继承会违背构造方法与类名相同的规则。
	成员变量	可以继承	可以继承	私有的成员变量无法直接调用，但仍然会被子类继承。
	成员方法    无法继承    可以继承	实际上是添加到虚方法表中的方法才能被子类继承。
	
	虚方法表：非private，非final，非static修饰的方法可以添加入虚方法表中，表中的方法可以被继承。
	
	创建子类实例时，会使用一部分内存存储从父类继承下来的成员变量。
	成员变量(成员方法同理)：当子类没有重新定义该变量时，this和super都是指向父类的该变量；当子类重新定义后，this和super指向的变量地址才有区别。
	
	方法的重写(@Override)：本质是覆盖从父类继承的虚方法表中的同名方法。
						 1.只有添加到虚方法表中的方法才能被重写。
						 2.重写的方法尽量与父类保持一致。
						 3.重写方法时子类的访问权限要大于等于父类。
						 4.重写方法时子类的返回值类型要小于等于父类。
						 
	构造方法:子类的构造方法会在第一行默认加上一个父类的空参构造super()，并且super()前不许有其他语句。
	this()(前不许有其他语句):调用子类的其他构造方法，此时该构造方法就不会加上super(),因为调用的其他构造方法会自带super()。
	
	标准的JavaBean：和之前的相同，空参构造、全参构造（包括父类的变量），子类的变量提供set和get方法，需要重写的方法以及子类的特殊方法。
	
	
	







 
